diff --git a/authcaptureproxy/auth_capture_proxy.py b/authcaptureproxy/auth_capture_proxy.py
index 0000000..0000000 100644
--- a/authcaptureproxy/auth_capture_proxy.py
+++ b/authcaptureproxy/auth_capture_proxy.py
@@ -1,6 +1,7 @@
 #  SPDX-License-Identifier: Apache-2.0
 """Python Package for auth capture proxy."""
 
+from __future__ import annotations
 import asyncio
 import logging
 import posixpath
@@ -62,6 +63,24 @@ class AuthCaptureProxy:
         self.session_factory: Callable[[], httpx.AsyncClient] = session_factory or (
             lambda: httpx.AsyncClient(verify=ssl_context)
         )
-        # NOTE: Do not instantiate httpx.AsyncClient inside Home Assistant's event loop.
-        # Some SSL initialization (e.g., load_verify_locations) is blocking and will be flagged.
-        # The session is created lazily via _ensure_session(), off the event loop using asyncio.to_thread().
-        self.session: Optional[httpx.AsyncClient] = session
+        # NOTE: Do not instantiate httpx.AsyncClient inside Home Assistant's event loop.
+        # Some SSL initialization (e.g., load_verify_locations) is blocking and will be flagged.
+        #
+        # Keep historical behavior when *not* in an event loop: create a session immediately.
+        # When in an event loop (e.g., HA config flow), defer and create lazily via _ensure_session()
+        # using asyncio.to_thread().
+        in_event_loop = False
+        try:
+            asyncio.get_running_loop()
+            in_event_loop = True
+        except RuntimeError:
+            in_event_loop = False
+
+        if session is not None:
+            self.session: Optional[httpx.AsyncClient] = session
+        elif in_event_loop:
+            self.session = None
+        else:
+            self.session = self.session_factory()
 
         self._proxy_url: URL = proxy_url
         self._host_url: URL = host_url
@@ -210,6 +229,7 @@ class AuthCaptureProxy:
         else:
             host_url = self._host_url
 
         # Ensure the HTTP session is created off the event loop thread.
         await self._ensure_session()
+        session = self.session
+        if session is None:  # pragma: no cover
+            return await self._build_response(text="Internal error: HTTP session not initialized")
 
         async def _process_multipart(reader: MultipartReader, writer: MultipartWriter) -> None:
             """Process multipart.
